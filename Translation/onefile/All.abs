module Cell;
export Cell, setToList;
import * from Transcription;
import * from Dna;
import * from Mrna;
import * from Ribosome;
import * from Protein;
import * from Degradation;
//import * from Logger;
//import * from Main;

def List<A> setToList<A>(Set<A> s) =
    if hasNext(s)
    then let (Pair<Set<A>,A> res) = next(s) in Cons(snd(res),setToList(fst(res)))
    else Nil;

interface Cell {
    Unit addMrna(String id, Mrna mrna);
    Mrna getMrna();
    Unit addProtein(Protein prot);
    Unit addRibosome(Ribosome ribo);

    Int getSumProtein();
    Int getQuantMrna(String id);
    Int getSumMrna();
    String getInfoMrna();
    Int getQuantRibosome();

    Unit removeProtein();
    Unit removeMrna(String id);
    Unit removeRibosomes(Int n);
}

/*
 * A cell is essentially a container for the actors (reactants)
 * DNAs, MRNAs, Ribosomes, Proteins, etc
 */
class Cell implements Cell {

    Map<String, List<Mrna>> mrnas = map[];
    //List<Mrna> mrnaStrands = list[];
    List<Protein> proteins = list[];
    Set<Ribosome> ribosomes = set[];

    /*
    Unit addMRNA(Mrna mrna) {
        mrnaStrands = appendright(mrnaStrands, mrna);
    }*/
    Unit addMrna(String id, Mrna mrna) {
        if (lookup(mrnas, id) == Nothing)
            mrnas = put(mrnas, id, list[]);
        List<Mrna> li = lookupUnsafe(mrnas, id);
        li = appendright(li, mrna);
        mrnas = put(mrnas, id, li);
    }


    Unit addRibosome(Ribosome ribo) {
        ribosomes = insertElement(ribosomes, ribo);
    }

    Unit removeRibosomes(Int n) {
        assert size(ribosomes) >= n;
        while(n > 0) {
            Ribosome r = take(ribosomes);
            await r!stop();
            ribosomes = remove(ribosomes, r);
            n = n - 1;
        }
    }

    Unit addProtein(Protein prot) {
        proteins = appendright(proteins, prot);
        println("New Protein " + proteinID(prot) + " (" + toString(length(proteins)) + ")");
    }

    Int getSumProtein() {
        await length(proteins) > 0;
        return length(proteins);
    }
    Unit removeProtein() {
        assert length(proteins) > 0;
        proteins = tail(proteins);
    }

    Int getQuantMrna(String id) {
        await lookup(mrnas, id) != Nothing;
        await length(lookupUnsafe(mrnas, id)) > 0;
        return length(lookupUnsafe(mrnas, id));
    }
    Int getSumMrna() {
        List<String> keys = elements(keys(mrnas));
        Int sum = 0;
        while(! isEmpty(keys)) {
            String id = head(keys);
            keys = tail(keys);
            sum = sum + length(lookupUnsafe(mrnas, id));
        }
        return sum;
    }
    String getInfoMrna() {
        List<String> keys = elements(keys(mrnas));
        String s = "";
        while(! isEmpty(keys)) {
            String id = head(keys);
            s = s + id + "(" + toString(length(lookupUnsafe(mrnas, id))) + ") ";
            keys = tail(keys);
        }
        return s;
    }

    Unit removeMrna(String id) {
        await length(lookupUnsafe(mrnas, id)) > 0;
        mrnas = put(mrnas, id, tail(lookupUnsafe(mrnas, id)));
    }
    Int getQuantRibosome() {
        return size(ribosomes);
    }


    /****************************************************************
     *** HTTP Callables ***
     */
    /***************************************************************/

    // Randomly return one of the mRNA strands for decoding
    Mrna getMrna() {
        await(size(keys(mrnas)) > 0);
        List<String> keys = elements(keys(mrnas));
        String id = nth(keys, random(length(keys)));
        await length(lookupUnsafe(mrnas, id)) > 0;
        Int n = random(length(lookupUnsafe(mrnas, id)));
        Mrna mrna = nth(lookupUnsafe(mrnas, id), n);
        return mrna;
    }
}


module Degradation;
export Degradation, ProteinDegradation, MrnaDegradation;
import * from Cell;

/*
 * A crude degradation mechanism
 * based on a given rate and the quantity of the respective reactant
 */

interface Degradation {
    Unit start();
    Unit stop();
    Bool isOn();
    Rat getRate();
    Unit setRate(Rat r);
    Unit run();
}


[Far]
class ProteinDegradation ([Final] Cell cell, Rat rate) implements Degradation {
    Bool run = True;
    uses RunD;
    uses ControlD;

    Int getQuantity() {
        return await cell!getSumProtein();
    }
    Unit degrade() {
        await cell!removeProtein();
    }
}

[Far]
class MrnaDegradation ([Final] Cell cell, String id, Rat rate) implements Degradation {
    Bool run = True;
    uses RunD;
    uses ControlD;

    Int getQuantity() {
        return await cell!getQuantMrna(id);
    }
    Unit degrade() {
        await cell!removeMrna(id);
    }
}


// FIXME: rename trait RunD to Run once the compiler is fixed
trait RunD = {
    Unit run() {
        assert rate > 0;
        while (True) {
            await this.run;
            Int quantity = this.getQuantity();
            assert quantity > 0;
            Rat d = 1 / (rate * quantity);
            this.degrade();
            duration(d, d);
        }
    }
}

trait ControlD = {
    Unit start() { run = True; }
    Unit stop() { run = False; }
    Bool isOn() { return run; }
    Rat getRate() { return rate; }
    Unit setRate(Rat r) {
        if (r > 0)
            this.rate = r;
    }
}
module Dna;
export Gene, id, code;
export Nucleotide, A, C, G, U, nuc;


data Gene = Gene(String id, List<Nucleotide> code);

// adenine, cytosine, guanine, uracil
data Nucleotide = A | C | G | U;

def Nucleotide nuc() =
    case random(4) {
        0 => A;
        1 => C;
        2 => G;
        3 => U;
    };

module Main;
import * from Cell;
import * from Dna;
import * from Ribosome;
import * from Transcription;
import * from Translation;
import * from Degradation;


interface HTTPInterface {
    [HTTPCallable] Int getSumMrna();
    [HTTPCallable] Pair<Time, Int> getTSumMrna();
    [HTTPCallable] String getInfoMrna();
    [HTTPCallable] Int getSumProtein();
    [HTTPCallable] Pair<Time, Int> getTSumProtein();
    [HTTPCallable] Int getQuantRibosome();
    [HTTPCallable] Pair<Time, Int> getTSumRibosome();

    [HTTPCallable] Unit setQuantRibosomes(Int n);
    [HTTPCallable] Unit setDegradation(Int index, Bool on, Int nom, Int den);
    [HTTPCallable] Unit setTranscription(Int index, Bool on, Int nom, Int den);

    [HTTPCallable] Pair<Bool, Rat> statusDegradationMrna();
    [HTTPCallable] Pair<Bool, Rat> statusDegradationProtein();
    [HTTPCallable] List<Rat> statusTranscription();
}

class Model([Near] Cell cell, List<Transcription> tscript, List<Degradation> deg) implements HTTPInterface {

    Unit setQuantRibosomes(Int n) {
        Int current = cell.getQuantRibosome();
        if (n < current) {
            // too many
            Int diff = current - n;
            cell.removeRibosomes(diff);
        } else {
            // too few
            Int diff = n - current;
            while (diff > 0) {
                Ribosome ribo = new Ribosome(cell);
                cell.addRibosome(ribo);
                diff = diff - 1;
                suspend;
            }
        }

    }

    Int getSumMrna() {
        return cell.getSumMrna();
    }
    Int getSumProtein() {
        return cell.getSumProtein();
    }
    Int getQuantRibosome() {
        return cell.getQuantRibosome();
    }

    Pair<Time,Int> getTSumMrna() {
        Int n = this.getSumMrna();
        return Pair(now(), n);
    }
    Pair<Time,Int> getTSumProtein() {
        Int n = this.getSumProtein();
        return Pair(now(), n);
    }
    Pair<Time,Int> getTSumRibosome() {
        Int n = this.getQuantRibosome();
        return Pair(now(), n);
    }

    String getInfoMrna() {
        return cell.getInfoMrna();

    }

    Pair<Bool, Rat> statusDegradationMrna() {
        /* FIXME
        Bool on = md.isOn();
        Rat rate = await md!getRate();
        return Pair(on, rate);
        */
        return Pair(True, 0);
    }
    Pair<Bool, Rat> statusDegradationProtein() {
        /* FIXME
        Bool on = await pd!isOn();
        Rat rate = await pd!getRate();
        return Pair(on, rate);
        */
        return Pair(True, 0);
    }



    Unit setDegradation(Int index, Bool on, Int nom, Int den) {
        Degradation d = nth(deg, index);
        d.setRate(nom/den);
        if (on)
            d.start();
        else
            d.stop();

    }

    Unit setTranscription(Int index, Bool on, Int num, Int den) {
        // TODO
    }

    List<Rat> statusTranscription() {
        List<Rat> rates = list[];
        foreach (ts in tscript) {
            Rat r = await ts!getRate();
            rates = appendright(rates, r);
        }
        return rates;
    }

}



/******************************************************************************
 *** Main block
 *****************************************************************************/

{
    [HTTPName: "Cell"] Cell cell = new local Cell();


    /* URA3 is a gene on chromosome V in Saccharomyces cerevisiae (yeast)
       http://www.yeastgenome.org/locus/S000000747/overview
       Chr 5 from 116121 to 117051
     */
    Gene ura3 = Gene("URA3", list[
            A,A,C,C,C,A,A,C,U,G,C,A,C,A,G,A,A,C,A,A,A,A,A,C,C,U,G,C,A,G,G,A,A,A,C,G,A,A,G,A,U,A,A,A,U,C,A,U,G,U,C,G,A,A,A,G,C,U,A,C,
            A,U,A,U,A,A,G,G,A,A,C,G,U,G,C,U,G,C,U,A,C,U,C,A,U,C,C,U,A,G,U,C,C,U,G,U,U,G,C,U,G,C,C,A,A,G,C,U,A,U,U,U,A,A,U,A,U,C,A,U,
            G,C,A,C,G,A,A,A,A,G,C,A,A,A,C,A,A,A,C,U,U,G,U,G,U,G,C,U,U,C,A,U,U,G,G,A,U,G,U,U,C,G,U,A,C,C,A,C,C,A,A,G,G,A,A,U,U,A,C,U,
            G,G,A,G,U,U,A,G,U,U,G,A,A,G,C,A,U,U,A,G,G,U,C,C,C,A,A,A,A,U,U,U,G,U,U,U,A,C,U,A,A,A,A,A,C,A,C,A,U,G,U,G,G,A,U,A,U,C,U,U,
            G,A,C,U,G,A,U,U,U,U,U,C,C,A,U,G,G,A,G,G,G,C,A,C,A,G,U,U,A,A,G,C,C,G,C,U,A,A,A,G,G,C,A,U,U,A,U,C,C,G,C,C,A,A,G,U,A,C,A,A,
            U,U,U,U,U,U,A,C,U,C,U,U,C,G,A,A,G,A,C,A,G,A,A,A,A,U,U,U,G,C,U,G,A,C,A,U,U,G,G,U,A,A,U,A,C,A,G,U,C,A,A,A,U,U,G,C,A,G,U,A,
            C,U,C,U,G,C,G,G,G,U,G,U,A,U,A,C,A,G,A,A,U,A,G,C,A,G,A,A,U,G,G,G,C,A,G,A,C,A,U,U,A,C,G,A,A,U,G,C,A,C,A,C,G,G,U,G,U,G,G,U,
            G,G,G,C,C,C,A,G,G,U,A,U,U,G,U,U,A,G,C,G,G,U,U,U,G,A,A,G,C,A,G,G,C,G,G,C,G,G,A,A,G,A,A,G,U,A,A,C,A,A,A,G,G,A,A,C,C,U,A,G,
            A,G,G,C,C,U,U,U,U,G,A,U,G,U,U,A,G,C,A,G,A,A,U,U,G,U,C,A,U,G,C,A,A,G,G,G,C,U,C,C,C,U,A,G,C,U,A,C,U,G,G,A,G,A,A,U,A,U,A,C,
            U,A,A,G,G,G,U,A,C,U,G,U,U,G,A,C,A,U,U,G,C,G,A,A,G,A,G,C,G,A,C,A,A,A,G,A,U,U,U,U,G,U,U,A,U,C,G,G,C,U,U,U,A,U,U,G,C,U,C,A,
            A,A,G,A,G,A,C,A,U,G,G,G,U,G,G,A,A,G,A,G,A,U,G,A,A,G,G,U,U,A,C,G,A,U,U,G,G,U,U,G,A,U,U,A,U,G,A,C,A,C,C,C,G,G,U,G,U,G,G,G,
            U,U,U,A,G,A,U,G,A,C,A,A,G,G,G,A,G,A,C,G,C,A,U,U,G,G,G,U,C,A,A,C,A,G,U,A,U,A,G,A,A,C,C,G,U,G,G,A,U,G,A,U,G,U,G,G,U,C,U,C,
            U,A,C,A,G,G,A,U,C,U,G,A,C,A,U,U,A,U,U,A,U,U,G,U,U,G,G,A,A,G,A,G,G,A,C,U,A,U,U,U,G,C,A,A,A,G,G,G,A,A,G,G,G,A,U,G,C,U,A,A,
            G,G,U,A,G,A,G,G,G,U,G,A,A,C,G,U,U,A,C,A,G,A,A,A,A,G,C,A,G,G,C,U,G,G,G,A,A,G,C,A,U,A,U,U,U,G,A,G,A,A,G,A,U,G,C,G,G,C,C,A,
            G,C,A,A,A,A,C,U,A,A,A,A,A,A,C,U,G,U,A,U,U,A,U,A,A,G,U,A,A,A,U,G,C,A,U,G,U,A,U,A,C,U,A,A,A,C,U,C,A,C,A,A,A,U,U,A,G,A,G,C,
            U,U,C,A,A,U,U,U,A,A,U,U,A,U,A,U,C,A,G,U,U,A,U,U,A,C,C,C,G,G,G]);
    /* ADH1, Alcohol dehydrogenase
     * http://www.yeastgenome.org/locus/ADH1/overview
     * Chr 15 from 159472 to 160644 reverse complement
     */
    Gene adh1 = Gene("ADH1", list[
            G,C,A,C,A,A,U,A,U,U,U,C,A,A,G,C,U,A,U,A,C,C,A,A,G,C,A,U,A,C,A,A,U,C,A,A,C,U,A,U,C,U,C,A,U,A,U,A,C,A,A,U,G,U,C,U,A,U,C,C,
            C,A,G,A,A,A,C,U,C,A,A,A,A,A,G,G,U,G,U,U,A,U,C,U,U,C,U,A,C,G,A,A,U,C,C,C,A,C,G,G,U,A,A,G,U,U,G,G,A,A,U,A,C,A,A,A,G,A,U,A,
            U,U,C,C,A,G,U,U,C,C,A,A,A,G,C,C,A,A,A,G,G,C,C,A,A,C,G,A,A,U,U,G,U,U,G,A,U,C,A,A,C,G,U,U,A,A,A,U,A,C,U,C,U,G,G,U,G,U,C,U,
            G,U,C,A,C,A,C,U,G,A,C,U,U,G,C,A,C,G,C,U,U,G,G,C,A,C,G,G,U,G,A,C,U,G,G,C,C,A,U,U,G,C,C,A,G,U,U,A,A,G,C,U,A,C,C,A,U,U,A,G,
            U,C,G,G,U,G,G,U,C,A,C,G,A,A,G,G,U,G,C,C,G,G,U,G,U,C,G,U,U,G,U,C,G,G,C,A,U,G,G,G,U,G,A,A,A,A,C,G,U,U,A,A,G,G,G,C,U,G,G,A,
            A,G,A,U,C,G,G,U,G,A,C,U,A,C,G,C,C,G,G,U,A,U,C,A,A,A,U,G,G,U,U,G,A,A,C,G,G,U,U,C,U,U,G,U,A,U,G,G,C,C,U,G,U,G,A,A,U,A,C,U,
            G,U,G,A,A,U,U,G,G,G,U,A,A,C,G,A,A,U,C,C,A,A,C,U,G,U,C,C,U,C,A,C,G,C,U,G,A,C,U,U,G,U,C,U,G,G,U,U,A,C,A,C,C,C,A,C,G,A,C,G,
            G,U,U,C,U,U,U,C,C,A,A,C,A,A,U,A,C,G,C,U,A,C,C,G,C,U,G,A,C,G,C,U,G,U,U,C,A,A,G,C,C,G,C,U,C,A,C,A,U,U,C,C,U,C,A,A,G,G,U,A,
            C,C,G,A,C,U,U,G,G,C,C,C,A,A,G,U,C,G,C,C,C,C,C,A,U,C,U,U,G,U,G,U,G,C,U,G,G,U,A,U,C,A,C,C,G,U,C,U,A,C,A,A,G,G,C,U,U,U,G,A,
            A,G,U,C,U,G,C,U,A,A,C,U,U,G,A,U,G,G,C,C,G,G,U,C,A,C,U,G,G,G,U,U,G,C,U,A,U,C,U,C,C,G,G,U,G,C,U,G,C,U,G,G,U,G,G,U,C,U,A,G,
            G,U,U,C,U,U,U,G,G,C,U,G,U,U,C,A,A,U,A,C,G,C,C,A,A,G,G,C,U,A,U,G,G,G,U,U,A,C,A,G,A,G,U,C,U,U,G,G,G,U,A,U,U,G,A,C,G,G,U,G,
            G,U,G,A,A,G,G,U,A,A,G,G,A,A,G,A,A,U,U,A,U,U,C,A,G,A,U,C,C,A,U,C,G,G,U,G,G,U,G,A,A,G,U,C,U,U,C,A,U,U,G,A,C,U,U,C,A,C,U,A,
            A,G,G,A,A,A,A,G,G,A,C,A,U,U,G,U,C,G,G,U,G,C,U,G,U,U,C,U,A,A,A,G,G,C,C,A,C,U,G,A,C,G,G,U,G,G,U,G,C,U,C,A,C,G,G,U,G,U,C,A,
            U,C,A,A,C,G,U,U,U,C,C,G,U,U,U,C,C,G,A,A,G,C,C,G,C,U,A,U,U,G,A,A,G,C,U,U,C,U,A,C,C,A,G,A,U,A,C,G,U,U,A,G,A,G,C,U,A,A,C,G,
            G,U,A,C,C,A,C,C,G,U,U,U,U,G,G,U,C,G,G,U,A,U,G,C,C,A,G,C,U,G,G,U,G,C,C,A,A,G,U,G,U,U,G,U,U,C,U,G,A,U,G,U,C,U,U,C,A,A,C,C,
            A,A,G,U,C,G,U,C,A,A,G,U,C,C,A,U,C,U,C,U,A,U,U,G,U,U,G,G,U,U,C,U,U,A,C,G,U,C,G,G,U,A,A,C,A,G,A,G,C,U,G,A,C,A,C,C,A,G,A,G,
            A,A,G,C,U,U,U,G,G,A,C,U,U,C,U,U,C,G,C,C,A,G,A,G,G,U,U,U,G,G,U,C,A,A,G,U,C,U,C,C,A,A,U,C,A,A,G,G,U,U,G,U,C,G,G,C,U,U,G,U,
            C,U,A,C,C,U,U,G,C,C,A,G,A,A,A,U,U,U,A,C,G,A,A,A,A,G,A,U,G,G,A,A,A,A,G,G,G,U,C,A,A,A,U,C,G,U,U,G,G,U,A,G,A,U,A,C,G,U,U,G,
            U,U,G,A,C,A,C,U,U,C,U,A,A,A,U,A,A,G,C,G,A,A,U,U,U,C,U,U,A,U,G,A,U,U,U,A,U,G,A,U,U,U,U,U,A,U,U,A,U,U,A,A,A,U,A,A,G,U,U,A,
            U,A,A,A,A,A,A,A,A,U,A,A,G,U,G,U,A,U,A,C,A,A,A,U,U,U,U,A,A,A,G,U,G]);
    /* Nucleolar S-adenosylmethionine-dependent rRNA methyltransferase
     * http://www.yeastgenome.org/locus/S000002490/overview
     * Chr 4   from 612060 to 613366
     */
    Gene rrp8 = Gene("RRP8", list[
            A,A,C,G,A,A,A,U,U,U,U,A,U,A,U,G,G,C,C,U,U,A,U,U,U,A,A,C,G,U,A,G,A,A,G,G,U,U,G,G,U,C,U,A,U,U,A,A,G,A,C,A,A,A,A,A,C,C,G,U,
            C,G,C,U,U,U,U,G,A,U,A,A,C,A,A,G,A,C,U,A,A,U,A,A,G,U,C,U,U,C,A,A,A,A,G,A,U,A,A,A,A,A,A,A,A,A,A,A,U,A,A,U,A,G,A,A,A,A,A,A,
            U,G,G,C,A,A,A,C,U,U,A,C,A,A,G,A,G,A,A,C,A,G,A,A,G,U,U,G,A,A,A,G,A,A,G,A,G,A,C,A,G,A,G,G,C,U,G,A,G,U,U,G,A,A,G,G,A,A,C,A,
            A,G,U,G,G,A,A,G,A,C,A,U,U,C,C,U,U,C,C,G,A,A,G,G,A,U,C,A,G,U,A,G,C,C,A,A,A,G,A,C,A,U,C,C,C,A,A,A,A,A,A,A,A,A,C,C,A,A,G,A,
            G,A,A,A,A,G,U,G,A,U,C,A,A,A,A,U,G,A,A,A,C,G,A,G,C,A,A,G,A,A,A,C,G,C,A,A,G,C,A,C,G,A,U,G,A,A,G,A,A,G,C,C,C,C,U,C,U,G,A,U,
            G,C,A,A,G,U,A,A,A,A,G,A,A,A,A,U,A,U,U,G,A,A,A,A,A,C,C,U,A,C,A,A,A,G,A,A,G,C,A,A,C,U,A,A,C,C,C,C,U,U,U,A,C,A,A,C,A,A,A,A,
            G,A,U,G,A,U,G,G,C,U,A,A,A,C,U,G,A,C,U,G,G,U,U,C,U,A,G,A,U,U,U,A,G,A,U,G,G,A,U,C,A,A,U,G,A,A,C,A,A,C,U,G,U,A,U,A,C,A,A,U,
            U,A,G,C,U,C,U,G,A,U,G,A,A,G,C,U,U,U,G,A,A,A,U,U,A,A,U,A,A,A,A,G,A,A,C,A,A,C,C,A,C,A,A,U,U,A,U,U,U,G,A,C,G,A,A,U,A,U,C,A,
            U,G,A,U,G,G,U,U,U,U,A,G,A,U,C,A,C,A,A,G,U,G,C,A,A,G,C,A,U,G,G,C,C,G,G,A,A,A,A,U,C,C,A,G,U,U,G,A,U,G,U,U,U,U,U,G,U,U,G,A,
            C,C,A,A,A,U,U,C,G,U,U,A,U,A,G,A,U,G,C,A,U,G,A,A,A,C,C,U,G,U,G,A,A,U,G,C,U,C,C,A,G,G,U,G,G,G,U,U,A,C,C,A,G,G,U,C,U,U,A,A,
            G,G,A,U,A,G,U,A,A,A,G,A,A,A,U,A,G,U,U,A,U,U,G,C,U,G,A,U,A,U,G,G,G,G,U,G,U,G,G,U,G,A,A,G,C,U,C,A,A,U,U,A,G,C,A,U,U,A,G,A,
            A,A,U,C,A,A,C,A,A,U,U,U,U,U,U,C,A,A,A,A,A,U,U,A,C,A,A,U,A,A,G,A,A,A,G,C,G,A,A,G,A,A,A,U,A,U,U,U,G,A,A,A,A,G,A,C,G,C,C,A,
            U,A,A,A,G,U,C,C,A,C,A,G,U,U,U,U,G,A,U,U,U,G,A,A,G,A,A,A,G,C,U,A,A,C,G,A,A,A,G,A,A,U,A,A,C,U,G,U,G,G,C,A,G,A,U,A,U,U,A,G,
            A,A,A,U,G,U,G,C,C,G,C,U,A,C,C,A,G,A,U,G,A,G,U,C,C,U,G,U,A,C,U,A,U,A,G,U,G,G,U,C,U,U,C,U,G,C,C,U,G,G,C,U,C,U,A,A,U,G,G,G,
            U,A,C,A,A,A,U,U,U,C,C,U,C,G,A,U,U,U,C,A,U,A,A,A,A,G,A,A,G,C,U,U,A,U,A,G,G,A,U,U,U,U,A,G,C,G,C,C,A,A,G,G,G,G,U,G,A,A,U,U,
            A,U,G,G,A,U,C,G,C,A,G,A,A,A,U,U,A,A,A,U,C,A,A,G,G,U,U,U,A,G,U,G,A,C,G,G,C,A,A,A,G,G,U,A,A,U,G,A,A,U,U,U,G,U,A,G,A,C,G,C,
            U,U,U,G,A,A,G,C,U,G,A,U,G,G,G,A,U,U,U,U,U,U,C,A,C,A,A,A,A,A,G,A,C,C,U,U,C,G,A,C,G,A,G,A,A,U,A,A,G,A,U,G,U,U,U,A,C,A,A,G,
            A,U,U,C,G,A,A,U,U,U,U,U,C,A,A,G,C,C,A,C,C,U,G,C,G,G,A,G,A,U,U,A,U,U,G,A,A,G,A,G,A,G,A,A,G,G,C,A,G,A,A,A,U,U,G,G,A,A,A,G,
            A,A,G,A,C,A,A,A,A,G,U,U,U,A,U,U,G,A,A,G,U,U,G,A,A,A,C,U,G,A,G,A,A,G,G,A,A,G,A,A,U,U,A,G,A,A,A,A,G,A,A,A,A,G,A,C,G,G,A,A,
            A,A,U,U,G,C,C,G,A,A,G,G,A,A,A,A,U,G,G,C,U,C,U,U,G,A,A,G,C,C,C,U,G,U,A,U,U,U,A,U,A,A,A,A,G,A,A,G,A,U,A,A,C,G,A,C,U,U,C,A,
            U,C,C,G,U,C,A,U,U,U,U,C,A,U,A,U,U,U,U,A,A,U,A,U,U,G,U,U,U,U,U,U,C,U,U,U,U,G,U,A,U,A,C,U,A,U,A,U,U,U,A,U,A,C,A,U,A,U,A,A,
            U,U,G,U,A,U,U,C,U,U,U,U,C,C,U,G,U,A,G,U,A,C,A,U,U,G,C,G,U,A,A,A,G,U,A,A,A,A,A,U,C,A,U,C,U,A,G]);


    // Start DNA to mRNA transcription of some genes
    // 0 -> mRNA, rate
    Transcription ts1 = new Transcription(ura3, cell, 1/2);
    Transcription ts2 = new Transcription(adh1, cell, 1/3);
    Transcription ts3 = new Transcription(rrp8, cell, 1/20);


    // Start degradation
    // Prot -> 0, rate
    // mRNA -> 0, rate
    Degradation md1 = new MrnaDegradation(cell, id(ura3), 1/50);
    Degradation md2 = new MrnaDegradation(cell, id(adh1), 1/50);
    Degradation md3 = new MrnaDegradation(cell, id(rrp8), 1/50);
    Degradation pd = new ProteinDegradation(cell, 1/50);


    // TODO
    Translation tl1 = new Translation(ura3);
    Translation tl2 = new Translation(adh1);
    Translation tl3 = new Translation(rrp8);

    // Initial populations
    // Translation of proteins in E. coli is carried out by ~10,000-100,000 ribosomes
    Int popRib = 50;

    // Populate cell with ribosomes
    Int i = 0;
    while (i < popRib) {
        Ribosome ribo = new Ribosome(cell);
        cell.addRibosome(ribo);
        i = i + 1;
    }

    /*
     * HTTP Interface
     */
    [HTTPName: "Model"] HTTPInterface model = new local Model(cell, list[ts1, ts2, ts3], list[md1, md2, md3, pd]);

}

module Mrna;
export Mrna, stop;
import * from Dna;
import * from Ribosome;


/* // Would be nice if this would work...
def Bool stop(List<Nucleotide> codon) =
    case codon {
        list[U, A, A] => true;
        list[U, A, G] => true;
        list[U, G, A] => true;
        _ => false;
    };
*/

def Bool stop(List<Nucleotide> codon) =
    case codon {
        Cons(U, Cons(A, Cons(A, Nil))) => True;
        Cons(U, Cons(A, Cons(G, Nil))) => True;
        Cons(U, Cons(G, Cons(A, Nil))) => True;
        _ => False;
    };


interface Mrna {
    Bool attach(Ribosome rib);
    Unit detach(Ribosome rib, Int pos);
    Int advance(Ribosome rib, Int pos);
    List<Nucleotide> readCodon(Int pos);
    Nucleotide readNucleotide(Int pos);
    String getID();
    String toString();
}

class Mrna([Final] String id, List<Nucleotide> code) implements Mrna {

    // This map remembers the positions of ribosomes in the mRNA strand
    // Only one ribosome can be at a certain position
    Map<Int, Maybe<Ribosome>> occupancy = map[];

    // init block (constructor)
    {
        Int i = 0;
        while(i < length(code)) {
            occupancy = put(occupancy, i, Nothing);
            i = i + 1;
        }
    }

    /*
    recover {
        _ => println("************");
    }
    */

    /* Attach ribosome at beginning of the strand
     * Return True if ribosome attached, else False
     */
    Bool attach(Ribosome rib) {
        Bool success = False;
        if (lookupUnsafe(occupancy, 0) == Nothing) {
            occupancy = put(occupancy, 0, Just(rib));
            success = True;
            //println("Ribosome attached to mRNA");
        }
        return success;
    }

    Unit detach(Ribosome rib, Int pos) {
        // assume rib is indeed at pos
        assert lookupUnsafe(occupancy, pos) == Just(rib);

        // clear pos
        occupancy = put(occupancy, pos, Nothing);
        //println("Ribosome detached from mRNA");
    }

    // Move the Ribosome rib from position pos to pos+1 (one nucleotide further)
    Int advance(Ribosome rib, Int pos) {
        assert pos < length(code) - 1;
        //wait until next position is free
        //println("waiting before pos " + toString(pos+1));
        await(lookupUnsafe(occupancy, pos+1) == Nothing);

        // clear current pos & move rib to next pos
        occupancy = put(put(occupancy, pos, Nothing), pos+1, Just(rib));

        //String s = this.occupancyToString();
        //println("Occupancy: " + s);
        return pos+1;
    }

    // Read codon at position pos
    List<Nucleotide> readCodon(Int pos) {
        List<Nucleotide> codon = list[nth(code, pos), nth(code, pos+1), nth(code, pos+2)];
        return codon;
    }

    Nucleotide readNucleotide(Int pos) {
        assert pos < length(code);
        return nth(code, pos);
    }


    String getID() {
        return id;
    }
    String toString() {
        return id + ": " + toString(code);
    }
    String occupancyToString() {
        String res = "";
        Int i = 0;
        while(i < size(keys(occupancy))) {
            if (lookupUnsafe(occupancy, i) == Nothing)
                res = res + "- ";
            else
                res = res + "* ";
            i = i + 1;
        }
        return res;
    }

}
module Protein;
export *;

// There are 20
data Aminoacid =
    Ala | Arg | Asn | Asp | Cys |
    Gln | Glu | Gly | His | Ile |
    Leu | Lys | Met | Phe | Pro |
    Ser | Thr | Trp | Tyr | Val ;

data Protein = Protein(String proteinID, List<Aminoacid> proteinAminoacids);

module Ribosome;
export Ribosome;
import * from Dna;
import * from Mrna;
import * from Cell;
import * from Protein;

interface Ribosome {
    Unit run();
    Unit stop();
}


/* Model of a ribosome
 * synthesizing protein from mRNA
 */
class Ribosome([Final] Cell cell) implements Ribosome {

    Bool run = True;
    Bool attached = False;
    Mrna mrna;
    Int position = -1; // The ribosome's current position on the mRNA strand
    String mrnaID = ""; // The mRNA's name (id)

    Unit run() {
        while (run) {
            /* Try to obtain mRNA; if successful,
             *     attach to mRNA,
             *     scan for start codon
             *     decode mRNA (codon by codon),
             *     detach upon encountering stop codon
             */
            mrna = await cell!getMrna();
            attached = await mrna!attach(this);
            position = 0;
            if (attached) {
                mrnaID = await mrna!getID();
                this.scan(mrna);
                this.decode(mrna);
            } else {
                //println("Ribosome failed to attach to mRNA");
            }
        }
        println("Ribosome retired");
    }

    Unit stop() {
        if (attached) {
            await mrna!detach(this, position);
            mrna = null;
        }
        run = False;
    }

    /* Look for the start codon
     */
    Unit scan(Mrna mrna) {
        Bool start = False;
        while (!start) {
            Nucleotide n = await mrna!readNucleotide(position);
            position = await mrna!advance(this, position);
            if (n == A) {
                n = await mrna!readNucleotide(position);
                position = await mrna!advance(this, position);
                if (n == U) {
                    n= await mrna!readNucleotide(position);
                    position = await mrna!advance(this, position);
                    if (n == G) {
                        start = True;
                    }
                }
            }
        }
    }

    Unit decode(Mrna mrna) {
        //println("Ribosome " + toString(this) + " starts decoding mrna at pos " + toString(position));
        List<Aminoacid> aminoacids = list[];
        Bool stop = False;
        while(!stop) {
            // read codon
            //println("position: " + toString(position));
            List<Nucleotide> codon = this.readCodon(mrna);
            if (stop(codon)) {
                stop = True;
                //println("Ribosome stops decoding mrna; at pos " + toString(position));
                await mrna!detach(this, position);
                //println("Stop decoding mrna");
                await cell!addProtein(Protein(mrnaID, aminoacids));
            } else {
                //print("Codon: " + toString(codon));
                Aminoacid aa = aminoacid(nth(codon, 0), nth(codon, 1), nth(codon, 2));
                //println("  --> Aminoacid: " + toString(aa));
                aminoacids = appendright(aminoacids, aa);
                Int r = random(20) + 1;
                await duration(1/r, 1/r); // Rate of translation by the ribosome [http://bionumbers.hms.harvard.edu/bionumber.aspx?id=100059]
                // Since not a stop codon, assume another codon is following
                Fut<Int> f = mrna!advance(this, position);
                position = f.get;

                //position = await mrna!advance(this, position);
            }
         }
    }

    List<Nucleotide> readCodon(Mrna mrna) {
        List<Nucleotide> codon = list[];
        // #1
        Nucleotide n = await mrna!readNucleotide(position);
        codon = appendright(codon, n);
        position = await mrna!advance(this, position);
        // #2
        n = await mrna!readNucleotide(position);
        codon = appendright(codon, n);
        position = await mrna!advance(this, position);
        // #3
        n = await mrna!readNucleotide(position);
        codon = appendright(codon, n);
        assert length(codon) == 3;
        return codon;
    }

}


// decode codon into specific amino acid
def Aminoacid aminoacid(Nucleotide n1, Nucleotide n2, Nucleotide n3) =
    case n1 {
        U => case n2 {
            U => case n3 {
                U => Phe;
                C => Phe;
                A => Leu;
                G => Leu;
            };
            C => Ser;
            A => case n3 {
                U => Tyr;
                C => Tyr;
            };
            G => case n3 {
                U => Cys;
                C => Cys;
                G => Trp;
            };
        };
        C => case n2 {
            U => Leu;
            C => Pro;
            A => case n3 {
                U => His;
                C => His;
                A => Gln;
                G => Gln;
            };
            G => Arg;
        };
        A => case n2 {
            U => case n3 {
                U => Ile;
                C => Ile;
                A => Ile;
                G => Met;
            };
            C => Thr;
            A => case n3 {
                U => Asn;
                C => Asn;
                A => Lys;
                G => Lys;
            };
            G => case n3 {
                U => Ser;
                C => Ser;
                A => Arg;
                G => Arg;
            };
        };
        G => case n2 {
            U => Val;
            C => Ala;
            A => case n3 {
                U => Asp;
                C => Asp;
                A => Glu;
                G => Glu;
            };
            G => Gly;
        };
    };
module Transcription;
export Transcription;
import * from Dna;
import * from Mrna;
import * from Cell;


interface Transcription {
    Unit start();
    Unit stop();
    Bool isOn();
    Rat getRate();
    Unit run();
}

[Far]
class Transcription([Final] Gene gene, [Final] Cell cell, Rat rate) implements Transcription {
    Bool run = True;
    uses Control;

    Unit run() {
        while(True) {
            await this.run;
            // TODO: implement the DNA->mRNA transcription process
            Mrna mrna = new Mrna(id(gene), code(gene));
            await cell!addMrna(id(gene), mrna);
            duration(1/rate, 1/rate);
        }

    }

}


/* Abstract transcription simulation by generating random mRNA strands of given length.
 * Corresponds to reaction: 0 -> mRNA (constant rate)
 */
[Far]
class TranscriptionRandom([Final] Cell cell, Rat rate) implements Transcription {
    Bool run = True;
    uses Control;

    Unit run() {
        while(True) {
            Mrna mrna = this.genMRNA(1000);
            await cell!addMrna("Random", mrna);
            duration(1/rate, 1/rate);
        }
    }

    /*
     * Generate random mRNA molecule of length len codons
     */
    Mrna genMRNA(Int len) {
        // We build the list starting from the end (more efficient)
        // first, a stop codon
        List<Nucleotide> code = list[U, A, A];

        Int i = 0;
        while (i < len*3) {
            // Add 3 random nucleotides (a codon) to mrna strand
            Nucleotide n1 = nuc();
            Nucleotide n2 = nuc();
            Nucleotide n3 = nuc();
            if (!stop(list[n1,n2,n3])) { // don't want any stop codons
                code = Cons(n1, code);
                code = Cons(n2, code);
                code = Cons(n3, code);
                i = i+3;
            }
        }

        // lastly, a start codon (A,U,G)
        code = Cons(G, code);
        code = Cons(U, code);
        code = Cons(A, code);

        assert length(code) == 3*(len+2);
        println("mRNA list generated, length=" + toString(length(code)));
        return new Mrna("Random", code);
    }

}



trait Control = {
    Rat getRate() { return rate; }
    Unit start() { run = True; }
    Unit stop() { run = False; }
    Bool isOn() { return run; }

}


module Translation;
export Translation;
import * from Dna;

interface Translation {}

class Translation(Gene gene) implements Translation {

    // init block (constructor)
    {


    }

    Unit run() {


    }
}

module M;


