module Mrna;
export Mrna, Nucleotide, A, C, G, U, nuc, stop;
import * from Ribosome;

// adenine, cytosine, guanine, uracil
data Nucleotide = A | C | G | U;

def Nucleotide nuc() =
    case random(4) {
        0 => A;
        1 => C;
        2 => G;
        3 => U;
    };


/* // Would be nice if this would work...
def Bool stop(List<Nucleotide> codon) =
    case codon {
        list[U, A, A] => true;
        list[U, A, G] => true;
        list[U, G, A] => true;
        _ => false;
    };
*/

def Bool stop(List<Nucleotide> codon) =
    case codon {
        Cons(U, Cons(A, Cons(A, Nil))) => True;
        Cons(U, Cons(A, Cons(G, Nil))) => True;
        Cons(U, Cons(G, Cons(A, Nil))) => True;
        _ => False;
    };


interface Mrna {
    Bool attach(Ribosome rib);
    Unit detach(Ribosome rib, Int pos);
    Int advance(Ribosome rib, Int pos);
    List<Nucleotide> readCodon(Int pos);
    Nucleotide readNucleotide(Int pos);
    String toString();
}

class Mrna(List<Nucleotide> code) implements Mrna {

    // This map remembers the positions of ribosomes in the mRNA strand
    // Only one ribosome can be at a certain position
    Map<Int, Maybe<Ribosome>> occupancy = map[];

    // init block (constructor)
    {
        Int i = 0;
        while(i < length(code)) {
            occupancy = put(occupancy, i, Nothing);
            i = i + 1;
        }
    }

    /*
    recover {
        _ => println("************");
    }
    */

    /* Attach ribosome at beginning of the strand
     * Return True if ribosome attached, else False
     */
    Bool attach(Ribosome rib) {
        Bool success = False;
        if (lookupUnsafe(occupancy, 0) == Nothing) {
            occupancy = put(occupancy, 0, Just(rib));
            success = True;
            //println("Ribosome attached to mRNA");
        }
        return success;
    }

    Unit detach(Ribosome rib, Int pos) {
        // assume rib is indeed at pos
        assert lookupUnsafe(occupancy, pos) == Just(rib);

        // clear pos
        occupancy = put(occupancy, pos, Nothing);
        //println("Ribosome detached from mRNA");

        // decoding the entire mrna takes 1, regadless of how long it is
        // TODO let decoding each codon have certain duration
        //duration(1,1);
    }

    // Move the Ribosome rib from position pos to pos+1 (one nucleotide further)
    Int advance(Ribosome rib, Int pos) {
        assert pos < length(code) - 1;
        //wait until next position is free
        //println("waiting before pos " + toString(pos+1));
        await(lookupUnsafe(occupancy, pos+1) == Nothing);

        // clear current pos & move rib to next pos
        occupancy = put(put(occupancy, pos, Nothing), pos+1, Just(rib));

        //String s = this.occupancyToString();
        //println("Occupancy: " + s);
        return pos+1;
    }

    // Read codon at position pos
    List<Nucleotide> readCodon(Int pos) {
        List<Nucleotide> codon = list[nth(code, pos), nth(code, pos+1), nth(code, pos+2)];
        return codon;
    }

    Nucleotide readNucleotide(Int pos) {
        assert pos < length(code);
        return nth(code, pos);
    }


    String toString() {
        return toString(code);
    }
    String occupancyToString() {
        String res = "";
        Int i = 0;
        while(i < size(keys(occupancy))) {
            if (lookupUnsafe(occupancy, i) == Nothing)
                res = res + "- ";
            else
                res = res + "* ";
            i = i + 1;
        }
        return res;
    }

}
