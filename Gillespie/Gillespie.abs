module Gillespie;
export *;
import * from ABS.StdLib;
import * from Math;

interface Substance {
    String getName();
}

interface Reaction {
    Unit addReactant(Substance r, Int n);
    Unit addProduct(Substance p, Int n);
    Unit start(Substrate env);
}

class Substance(String name) implements Substance { 
    String getName() { return name; }
}


/* 
 * Reaction: 
 *      multiset of reactants -> multiset of products
 *      A reaction gets its reactants from and releases its products into the environment
 */
class Reaction() implements Reaction {
    Map<Substance, Int> reactants = EmptyMap;
    Map<Substance, Int> products = EmptyMap;
     
    Unit addReactant(Substance r, Int n) {
        reactants = insert(reactants, Pair(r, n));
    }
    Unit addProduct(Substance p, Int n) {
        products = insert(products, Pair(p, n));
    }
    Unit start(Substrate env) {
        while(True) {
            Bool can = await env!consumeSubstances(reactants);
            if (can) {
                await env!produceSubstances(products);
            }
        }
    }

}

/* This is the environment 
 * - it contains some substances
 * - that react with each other according to the defined reactions
 *
 */
interface Substrate {
    Bool consumeSubstances(Map<Substance, Int> consumption);
    Unit produceSubstances(Map<Substance, Int> production);
    Unit run();
}

class Substrate(Map<Substance, Int> substances, Set<Reaction> reactions) implements Substrate {
    
    Unit run() {
        // start all reactions
        while (hasNext(reactions)) {
            Reaction r = take(reactions);
            r!start(this);
        }
    }
    
    Bool consumeSubstances(Map<Substance, Int> consumption) {
        Bool success = False;
        Set<Substance> availableSubstances = keys(substances);
	    Set<Substance> requiredSubstances = keys(consumption);

        // Test if every required substance exists in the required quantity
	    Bool continue = True;
	    while (hasNext(requiredSubstances) && continue) {
	        Substance s = take(requiredSubstances);
	        requiredSubstances = remove(requiredSubstances, s);
	        Int q = lookupUnsafe(consumption, s);
	        
	        if (contains(availableSubstances, s)) {
	            Int availableQuantity = lookupUnsafe(substances, s);
	            if (q > availableQuantity) {
	                continue = False;
	            }
	        } else {
                continue = False;
	        }
	    }
	    
	    if (continue) {
		    // Consume the substances
		    Set<Substance> consumedSubstances = keys(consumption);
		    while (hasNext(consumedSubstances)) {
		        Substance s = take(consumedSubstances);
		        consumedSubstances = remove(consumedSubstances, s);
		        Int q = lookupUnsafe(consumption, s);
		        Int availableQuantity = lookupUnsafe(substances, s);
		        put(substances, s, availableQuantity - q);
		    }
		    success = True;
		} else {
		    success = False;
		}
		return success;
    }

    Unit produceSubstances(Map<Substance, Int> production) {
        Set<Substance> producedSubstances = keys(production);
        while (hasNext(keys(production))) {
            Substance s = take(producedSubstances);
            Int q = lookupUnsafe(production, s);
            substances = insert(substances, Pair(s, q));
        }
    }
}


